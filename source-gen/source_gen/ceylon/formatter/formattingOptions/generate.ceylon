import ceylon.file { Writer, parsePath, File, Resource, Nil }
shared void generate() {
    Resource resource = parsePath("source/ceylon/formatter/options/FormattingOptions.ceylon").resource;
    File file;
    if (is Nil resource) {
        file = resource.createFile();
    } else {
   	    assert (is File resource);
   	    file = resource;
    }
    Writer writer = file.Overwriter();
    try {
        writeHeader(writer);
        generateSparseFormattingOptions(writer);
        generateFormattingOptions(writer);
        generateCombinedOptions(writer);
        generateVariableOptions(writer);
    } finally {
        writer.close(null);
    }
}

void writeHeader(Writer writer) {
    writer.write(
        "/*
          * DO NOT MODIFY THIS FILE
          *
          * It is generated by the source_gen.ceylon.formatter module (folder source-gen),
          * specifically the formattingOptions package therein.
          */
         
         ");
}

void generateSparseFormattingOptions(Writer writer) {
    writer.write(
        "\"A superclass of [[FormattingOptions]] where attributes are optional.
         
          The indented use is that users take a \\\"default\\\" `FormattingOptions` object and apply some
          `SparseFormattingOptions` on top of it using [[CombinedOptions]]; this way, they don't have
          to specify every option each time that they need to provide `FormattingOptions` somewhere.\"\n");
    writer.write("shared class SparseFormattingOptions(");
    variable Boolean needsComma = false;
    for (option in formattingOptions) {
        if (needsComma) {
        	writer.write(",");
        }
        writer.write("\n        ``option.name`` = null");
        needsComma = true;
    }
    writer.write(") {\n");
    for (option in formattingOptions) {
        writer.write("\n    \"``option.documentation``\"\n");
        writer.write("    shared default ``option.type``? ``option.name``;\n");
    }
    writer.write("}\n\n");
}

void generateFormattingOptions(Writer writer) {
    writer.write(
        "\"A bundle of options for the formatter that control how the code should be formatted.
         
          The default arguments are modeled after the `ceylon.language` module and the Ceylon SDK.
          You can refine them using named arguments:
          
              FormattingOptions {
                  indentMode = Tabs(4);
                  // modify some others
                  // keep the rest
              }\"\n");
    writer.write("shared class FormattingOptions(");
    variable Boolean needsComma = false;
    for (option in formattingOptions) {
        if (needsComma) {
        	writer.write(",");
        }
        writer.write("\n        ``option.name`` = ``option.defaultValue``");
        needsComma = true;
    }
    writer.write(") extends SparseFormattingOptions() {\n");
    for (option in formattingOptions) {
        writer.write("\n    \"``option.documentation``\"\n");
        writer.write("    shared actual default ``option.type`` ``option.name``;\n");
    }
    writer.write("}\n\n");
}

void generateCombinedOptions(Writer writer) {
    writer.write(
        "\"A combination of several [[FormattingOptions]], of which some may be [[Sparse|SparseFormattingOptions]].
         
          Each attribute is first searched in each of the [[decoration]] options, in the order of their appearance,
          and, if it isn't present in any of them, the attribute of [[baseOptions]] is used.
          
          In the typical use case, `foundation` will be some default options (e.g. `FormattingOptions()`), and 
          `decoration` will be one `SparseFormattingOptions` object created on the fly:
          
              FormattingVisitor(tokens, writer, CombinedOptions(defaultOptions,
                  SparseFormattingOptions {
                      indentMode = Mixed(Tabs(8), Spaces(4));
                      // ...
                  }));\"\n");
    writer.write("shared class CombinedOptions(FormattingOptions baseOptions, SparseFormattingOptions+ decoration) extends FormattingOptions() {\n");
    for(option in formattingOptions) {
        writer.write("\n    shared actual ``option.type`` ``option.name`` {\n");
        writer.write("        for (options in decoration) {\n");
        writer.write("            if (exists option = options.``option.name``) {\n");
        writer.write("                return option;\n");
        writer.write("            }\n");
        writer.write("        }\n");
        writer.write("        return baseOptions.``option.name``;\n");
        writer.write("    }\n");
    }
    writer.write("}\n\n");
}

void generateVariableOptions(Writer writer) {
    writer.write(
        "\"A subclass of [[FormattingOptions]] that makes its attributes [[variable]].
          
          For internal use only.\"\n");
    writer.write("class VariableOptions(FormattingOptions baseOptions) extends FormattingOptions() {\n\n");
    for(option in formattingOptions) {
        writer.write("    shared actual variable ``option.type`` ``option.name`` = baseOptions.``option.name``;\n");
    }
    writer.write("}");
}